

/***************************** Include Files *******************************/
#include "hdmi_text_controller.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "sleep.h"

#include <xtmrctr.h>
#include "xintc.h"
/************************** Function Definitions ***************************/

void textHDMIColorClr()
{
	for (int i = 0; i<(ROWS*COLUMNS); i++)
	{
		hdmi_ctrl->VRAM[i] = 0x00;
	}
}

void drawPixel(int x, int y, uint8_t color)
{

	int index = (y*COLUMNS + x)/2;
	uint8_t current = hdmi_ctrl->VRAM[index];
	uint8_t shifted = current;
	if((y*COLUMNS + x)%2 == 0) {
		if((current & 0x0F) == color) {
			return;
		}
		hdmi_ctrl->VRAM[index] = (current & 0xF0) | (color);
	}	else {
		if(((shifted & 0xF0) >> 4)==color) {
			return;
		}
		hdmi_ctrl->VRAM[index] = (current & 0x0F) | (color << 4);
	}	
}

uint8_t readPixel(int x, int y) {
	int index = (y*COLUMNS + x)/2;
	if((y*COLUMNS + x)%2 == 0) {
		return hdmi_ctrl->VRAM[index] & 0x0F;
	}	else {
		return ((hdmi_ctrl->VRAM[index] & 0xF0) >> 4);
	}
}

void drawNote(int lane, int y) {
    uint8_t color;
    int curr_y;
    if(y-5<0) {
        curr_y = 0;
    } else {
        curr_y = y-5;
    }
    for(; (curr_y < y+30) && (curr_y<480) ; curr_y++) {
        if(curr_y<0) {
            continue;
        }
        if(curr_y<y) {
            color = 0;
        } else {
            if(lane==0 || lane == 3) {
                    color = white;
            } else {
                color = cyan;
            }
        }
        uint8_t row_color = readPixel(lane*49+2,curr_y);
        if(row_color == color || row_color == red || row_color == orange || row_color == yellow || row_color == green) {
            continue;
        }
        for(int x=lane*49+2; x < lane*49+49+2; x++) {
            drawPixel(x,curr_y,color);
        }
    }
}

void removeNote(int lane, int y) {
    uint8_t color;
    int curr_y;
    if(y-5<0) {
        curr_y = 0;
    } else {
        curr_y = y-5;
    }
    for(; (curr_y < y+30) && (curr_y<480) ; curr_y++) {
        if(curr_y<0) {
            continue;
        }
        color = 0;
        uint8_t row_color = readPixel(lane*49+2,curr_y);
        if(row_color == color || row_color == red || row_color == orange || row_color == yellow || row_color == green) {
            continue;
        }
        for(int x=lane*49+2; x < lane*49+49+2; x++) {
            drawPixel(x,curr_y,color);
        }
    }
}

int scoreCalc(int hitY, int expY, int lane){
	int score;
//	xil_printf("Hit Y: %d\n", hitY);
//	xil_printf("Exp Y: %d\n", expY);
    int diff = abs(hitY - expY);
//    xil_printf("ABS: %d\n", diff);
    if (diff < 8)
    	score = 100;
    else if (diff < 20)
    	score = 50;
    else if (diff < 30)
        score = 20;
    else
        score = 0;

    return score;
}

void clickedFunc(uint8_t keycode[4], uint8_t prev_lane_pressed[4], uint8_t clicked[4])
{
    for (int i = 0; i < 4; i++) {
    	clicked[i] = 0;
    }
    uint8_t lane_pressed[4] = {0};
    for (int i = 0; i < 4; i++) {
        switch (keycode[i]) {
            case 0x07: lane_pressed[0] = 1; break; // 'd'
            case 0x09: lane_pressed[1] = 1; break; // 'f'
            case 0x0D: lane_pressed[2] = 1; break; // 'j'
            case 0x0E: lane_pressed[3] = 1; break; // 'k'
            default: break;
        }
    }


    for (int lane = 0; lane < 4; lane++) {
        if (!prev_lane_pressed[lane] && lane_pressed[lane]) {
            clicked[lane] = 1;
        }
        prev_lane_pressed[lane] = lane_pressed[lane];
    }
}

int isPressed(uint8_t *prev, uint8_t *curr)
{
    for(int i = 0; i < 6; i++) {
        if(curr[i] != 0 && curr[i] == prev[i]) return 1; // still held
    }
    return 0; // all keys released
}

void lightKeys(uint8_t keycode[4], uint8_t score)
{
	int color;
    for (int x = 0; x < COLUMNS; x++) {
        for (int y = ROWS - 33; y < ROWS - 29; y++) {
            drawPixel(x, y, 1);
        }
    }


    if (score == 100){
    	color = green;
    } else if (score == 50){
    	color = yellow;
    } else if (score == 20){
    	color = orange;
    } else {
    	color = red;
    }


    for (int i = 0; i < 4; i++) {
        switch (keycode[i]) {
            case 0x07: // 'd'
                for (int x = 24 - 3; x < 24 + 3; x++) {
                    for (int y = ROWS - 33; y < ROWS - 29; y++) {
                        drawPixel(x, y, color);
                    }
                }
                break;
            case 0x09: // 'f'
                for (int x = 74 - 3; x < 74 + 3; x++) {
                    for (int y = ROWS - 33; y < ROWS - 29; y++) {
                        drawPixel(x, y, color);
                    }
                }
                break;
            case 0x0D: // 'j'
                for (int x = 124 - 3; x < 124 + 3; x++) {
                    for (int y = ROWS - 33; y < ROWS - 29; y++) {
                        drawPixel(x, y, color);
                    }
                }
                break;
            case 0x0E: // 'k'
                for (int x = 174 - 3; x < 174 + 3; x++) {
                    for (int y = ROWS - 33; y < ROWS - 29; y++) {
                        drawPixel(x, y, color);
                    }
                }
                break;
            default:
                break;
        }
    }
}

void playGame() {
	int counter = 0;
	uint8_t score = 0;
	int totScore = 0;
	timer();
	uint8_t should_poll = 0;

	textHDMIColorClr();

	for(int x = 0; x < 200; x++) {
	    for(int y = 0; y < 480; y++) {
	        if((y > 447 && y < 451) || (x >= 0 && x < 2) || (x >= 198 && x < 200)) {
	            drawPixel(x, y, 1);
	        }
	    }
	}

	while (1) {
		MAX3421E_Task();
		USB_Task();

		if (GetUsbTaskState() != USB_STATE_RUNNING) break;

		if (device == 1) {
			if(should_poll == 0) {
				kbdPoll(&kbdbuf);
				for(int i = 0; i < 4; i++) {
					if(kbdbuf.keycode[i] == 0x28) return;
				}
				should_poll = 1;
			} else {
				should_poll = (should_poll + 1) % 3;
			}

			if (XTmrCtr_GetValue(&Usb_timer2, 0) >= 0x300000) {
				clickedFunc(kbdbuf.keycode, prev_lane_pressed, clicked);
				counter += 5;
				resetTimer();

				for(int i=0; i<6; i++) {
					int drawY = chart[i].y + counter;
					int ybot = drawY + 30;
					if(chart[i].lane != -1 && ybot > -10 && ybot < 529) {
						drawNote(chart[i].lane, drawY);
						if(clicked[chart[i].lane] == 1) {
							if(ybot > 390) {
								score = scoreCalc(ybot, 449, chart[i].lane);
								totScore += score;
								printHex(to_hex(totScore)<<8, 1);
								removeNote(chart[i].lane, drawY);
								clicked[chart[i].lane] = 0;
								chart[i].lane = -1;
							}
						}
					}
				}

				lightKeys(kbdbuf.keycode, score);

				for(int i=0; i<4; i++) {
					if(prevKeycode[i] != 0 && kbdbuf.keycode[i] == 0){
						score = 0;
					}
					prevKeycode[i] = kbdbuf.keycode[i];
				}
			}
		}
	}
}
