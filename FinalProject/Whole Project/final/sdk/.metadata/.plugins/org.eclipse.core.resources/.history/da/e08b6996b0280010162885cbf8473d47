/* MAX3421E low-level functions                             */
/* reading, writing registers, reset, host transfer, etc.   */
/* GPIN, GPOUT are as per tutorial, reassign if necessary   */
/* USB power on is GPOUT7, USB power overload is GPIN7      */

#define _MAX3421E_C_

#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "project_config.h"
#include "xparameters.h"
#include <unistd.h>
#include <xspi.h>
#include <xgpio.h>
#include <xtmrctr.h>
#include "xintc.h"

/* variables and data structures */

/* External variables */

extern BYTE usb_task_state;
static XSpi SpiInstance;
static int Status;
static XGpio Gpio_rst;
static XGpio Gpio_int;
static XSpi_Config *ConfigPtr;	/* Pointer to Configuration data */
XTmrCtr Usb_timer;

//Initialization of SPI port is already done for you
void SPI_init() {

	//xil_printf("Initializing SPI\n");

	ConfigPtr = XSpi_LookupConfig(XPAR_SPI_USB_DEVICE_ID);
	if (ConfigPtr == NULL) {
		return XST_DEVICE_NOT_FOUND;
	}

//	Status = XSpi_CfgInitialize(&SpiInstance, ConfigPtr,
//				  ConfigPtr->BaseAddress);
//	if (Status != XST_SUCCESS) {
//		return XST_FAILURE;
//	}
//
//	if (Status != XST_SUCCESS)
//	{
//		//xil_printf ("SPI device failed to initialize %d", Status);
//	}
//	Status = XSpi_SetOptions(&SpiInstance, XSP_MASTER_OPTION | XSP_MANUAL_SSELECT_OPTION);
//	if (Status != XST_SUCCESS)
//	{
//		//xil_printf ("SPI device failed to go into master mode %d", Status);
//	}

	XSpi_Start(&SpiInstance);
	XSpi_IntrGlobalDisable(&SpiInstance);
}

BYTE SPI_wr(BYTE data) {
	return 0; //This function is not needed
}


/* Functions    */
/* Single host register write   */
void MAXreg_wr(BYTE reg, BYTE val) {
	XSpi_SetSlaveSelect(&SpiInstance, 1);
	BYTE buffer[] = {reg+2, val};
	Status = XSpi_Transfer(&SpiInstance, buffer, NULL, 2);
	if (Status != 0)
	{
		//xil_printf ("SPI device failed to write %d", Status);
	}
	XSpi_SetSlaveSelect(&SpiInstance, 0);
}


/* multiple-byte write */
BYTE* MAXbytes_wr(BYTE reg, BYTE nbytes, BYTE* data) {
	XSpi_SetSlaveSelect(&SpiInstance, 1);
	BYTE *buff = malloc(nbytes+1);
	buff[0] = reg+2;
	for(int i = 1; i < nbytes+1; i++){
		buff[i] = data[i-1];
	}
	Status = XSpi_Transfer(&SpiInstance, buff, NULL, nbytes+1);
	if (Status != 0)
	{
		//xil_printf ("SPI device failed to write %d", Status);
	}
	XSpi_SetSlaveSelect(&SpiInstance, 0);
	return(data + nbytes);
}

BYTE MAXreg_rd(BYTE reg) {
	XSpi_SetSlaveSelect(&SpiInstance, 1);
	BYTE send_buffer[] = {reg, 0};
	BYTE rec_buffer[] = {0, 0};
	Status = XSpi_Transfer(&SpiInstance, send_buffer, rec_buffer, 2);
	if (Status != 0)
	{
		//xil_printf ("SPI device failed to read %d", Status);
	}
	XSpi_SetSlaveSelect(&SpiInstance, 0);
	return rec_buffer[1];
}

BYTE* MAXbytes_rd(BYTE reg, BYTE nbytes, BYTE* data) {
	XSpi_SetSlaveSelect(&SpiInstance, 1);
	BYTE *send_buff = malloc(nbytes+1);
	BYTE *rec_buff = malloc(nbytes+1);
	for(int i = 0; i < nbytes+1; i++){
		send_buff[i] = 0;
		rec_buff[i] = 0;
	}
	send_buff[0] = reg;
	Status = XSpi_Transfer(&SpiInstance, send_buff, rec_buff, nbytes+1);
	if (Status != 0)
	{
		//xil_printf ("SPI device failed to read %d", Status);
	}
	for(int i = 0; i < nbytes; i++){
		data[i] = rec_buff[i+1];
	}
	XSpi_SetSlaveSelect(&SpiInstance, 0);
	free(send_buff);
	free(rec_buff);
	return (data + nbytes);
}

void MAX3421E_reset(void) {
	Status = XGpio_Initialize(&Gpio_rst, XPAR_GPIO_USB_RST_DEVICE_ID);
	XGpio_SetDataDirection(&Gpio_rst, 1, 0);
	Status = XGpio_Initialize(&Gpio_int, XPAR_GPIO_USB_INT_DEVICE_ID);
	XGpio_SetDataDirection(&Gpio_int, 1, ~1);

	XGpio_DiscreteClear(&Gpio_rst, 1, 0x1);
	//xil_printf ("Holding USB in Reset\n");
	for (int delay = 0; delay < 0x7FFFF; delay ++){}
	XGpio_DiscreteSet(&Gpio_rst, 1, 0x1);
	//xil_printf ("Revision is: %d, if this reads 0 check your MAXreg_rd \n", MAXreg_rd( rREVISION));
	BYTE tmp = 0;

	MAXreg_wr( rUSBCTL, bmCHIPRES);
	MAXreg_wr( rUSBCTL, 0x00);

	//xil_printf("Waiting for PLL to stabilize: ");
	while (!(MAXreg_rd( rUSBIRQ) & bmOSCOKIRQ)) {
		tmp++;
		//xil_printf(".\n");
		if (tmp == 0) {
			//xil_printf("reset timeout!, check your MAXreg_wr\n");
		}
	}
}

BOOL Vbus_power(BOOL action) {
    BYTE tmp = MAXreg_rd( rIOPINS1 );
    if( action ) {
        tmp |= bmGPOUT0;
    }
    else {
        tmp &= ~bmGPOUT0;
    }
    MAXreg_wr( rIOPINS1,tmp );
    for (int delay = 0; delay < 0xFFFFF; delay ++){}
    //xil_printf ("VBUS power state change \n");
    return( TRUE );
	return (1);
}

void MAX_busprobe(void) {
	BYTE bus_sample;

	bus_sample = MAXreg_rd( rHRSL);
	bus_sample &= ( bmJSTATUS | bmKSTATUS);

	switch (bus_sample) {
	case ( bmJSTATUS):
		if (usb_task_state != USB_ATTACHED_SUBSTATE_WAIT_RESET_COMPLETE) {
			if (!(MAXreg_rd( rMODE) & bmLOWSPEED)) {
				MAXreg_wr( rMODE, MODE_FS_HOST);
				//xil_printf("Starting in full speed\n");
			} else {
				MAXreg_wr( rMODE, MODE_LS_HOST);
				//xil_printf("Starting in low speed\n");
			}
			usb_task_state = ( USB_STATE_ATTACHED);
		}
		break;
	case ( bmKSTATUS):
		if (usb_task_state != USB_ATTACHED_SUBSTATE_WAIT_RESET_COMPLETE) {
			if (!(MAXreg_rd( rMODE) & bmLOWSPEED)) {
				MAXreg_wr( rMODE, MODE_LS_HOST);
				//xil_printf("Starting in low speed\n");
			} else {
				MAXreg_wr( rMODE, MODE_FS_HOST);
				//xil_printf("Starting in full speed\n");
			}
			usb_task_state = ( USB_STATE_ATTACHED);
		}
		break;
	case ( bmSE1):
		usb_task_state = ( USB_DETACHED_SUBSTATE_ILLEGAL);
		break;
	case ( bmSE0):
		if (!((usb_task_state & USB_STATE_MASK) == USB_STATE_DETACHED))
			usb_task_state = ( USB_DETACHED_SUBSTATE_INITIALIZE);
		else {
			MAXreg_wr( rMODE, MODE_FS_HOST);
			usb_task_state = ( USB_DETACHED_SUBSTATE_WAIT_FOR_DEVICE);
		}
		break;
	}
}

void MAX3421E_init(void) {
	SPI_init();
	MAXreg_wr( rPINCTL, (bmFDUPSPI + bmINTLEVEL + bmGPXB));
	MAX3421E_reset();

	Status = XTmrCtr_Initialize(&Usb_timer, XPAR_TIMER_USB_AXI_DEVICE_ID);
	if (Status != XST_SUCCESS) {
		//xil_printf ("Timer instantiation failed\n");
	}
	XTmrCtr_Start(&Usb_timer, 0);

	//xil_printf ("The following should be about 1 second ticks. If they are not, check your timer \n");

	Vbus_power( OFF);
	Vbus_power( ON);

	MAXreg_wr( rMODE, bmDPPULLDN | bmDMPULLDN | bmHOST | bmSEPIRQ);
	MAXreg_wr( rHIEN, bmCONDETIE);
	MAXreg_wr(rHCTL, bmSAMPLEBUS);
	MAX_busprobe();
	MAXreg_wr( rHIRQ, bmCONDETIRQ);
	MAXreg_wr( rCPUCTL, 0x01);
}

void MAX3421E_Task(void) {
	if (XGpio_DiscreteRead(&Gpio_int, 1) & 0x01 == 0) {
		//xil_printf("MAX interrupt\n\r");
		MaxIntHandler();
	}
	// GPX not used
}

void MaxIntHandler(void) {
	BYTE HIRQ;
	BYTE HIRQ_sendback = 0x00;
	HIRQ = MAXreg_rd( rHIRQ);
	//xil_printf("IRQ: %x\n", HIRQ);
	if (HIRQ & bmFRAMEIRQ) {
		HIRQ_sendback |= bmFRAMEIRQ;
	}
	if (HIRQ & bmCONDETIRQ) {
		MAX_busprobe();
		HIRQ_sendback |= bmCONDETIRQ;
	}
	if (HIRQ & bmSNDBAVIRQ)
	{
		MAXreg_wr(rSNDBC, 0x00);
	}
	if (HIRQ & bmBUSEVENTIRQ) {
		usb_task_state++;
		HIRQ_sendback |= bmBUSEVENTIRQ;
	}
	MAXreg_wr( rHIRQ, HIRQ_sendback);
}

void MaxGpxHandler(void) {
	BYTE GPINIRQ;
	GPINIRQ = MAXreg_rd( rGPINIRQ);
}
