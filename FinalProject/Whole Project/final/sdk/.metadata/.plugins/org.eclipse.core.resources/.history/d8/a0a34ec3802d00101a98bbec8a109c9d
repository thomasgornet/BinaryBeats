#include <stdio.h>
#include "platform.h"
#include "lw_usb/GenericMacros.h"
#include "lw_usb/GenericTypeDefs.h"
#include "lw_usb/MAX3421E.h"
#include "lw_usb/USB.h"
#include "lw_usb/usb_ch9.h"
#include "lw_usb/transfer.h"
#include "lw_usb/HID.h"

#include "xparameters.h"
#include <xgpio.h>

#include <xtmrctr.h>
#include "xintc.h"

extern HID_DEVICE hid_device;

static XGpio Gpio_hex;

XTmrCtr Usb_timer2;
static int Status;

//static BYTE addr = 1; 				//hard-wired USB address
const char* const devclasses[] = { " Uninitialized", " HID Keyboard", " HID Mouse", " Mass storage" };

typedef struct{
    int lane;
    int y;

}Note;

#define eighth_scale -129
#define offset -1100
#define size 272
Note chart[size];
Note const_chart[size] = {
		        {0, 0},
		        {3, 1},
		        {2, 2},
		        {1, 5},
		        {3, 8},
		        {1, 16},
				{0, 17},
				{2, 18},
				{1, 21},
				{3, 24},
				{3, 32},
				{0, 33},
				{2, 34},
				{0, 37},
				{1, 40},
				{0, 48},
				{2, 49},
				{3, 50},
				{2, 53},
				{0, 56},
				{3, 59},
				{2, 64},
				{0, 66},
				{3, 66},
				{1, 69},
				{2, 69},
				{1, 74},
				{3, 74},
				{0, 77},
				{2, 77},
		        {0, 82},
				{1, 82},
				{2, 85},
				{3, 85},
				{1, 90},
				{3, 91},
				{2, 93},
				{0, 94},
				{2, 98},
				{3, 98},
				{1, 101},
				{3, 101},
				{0, 106},
				{2, 106},
				{1, 109},
				{2, 109},
				{0, 114},
				{1, 114},
				{2, 118},
				{0, 120},
				{3, 120},
				{1, 121},
				{2, 121},
				{0, 126},
				{2, 126},
				{2, 130},
				{3, 130},
				{0, 132},
				{1, 132},
				{2, 134},
				{0, 136},
				{3, 136},
				{1, 138},
				{0, 140},
				{2, 140},
				{3, 142},
				{2, 144},
				{1, 144},
				{0, 146},
				{2, 148},
				{3, 148},
				{1, 150},
				{0, 152},
				{2, 152},
				{3, 154},
				{0, 156},
				{1, 156},
				{3, 158},
				{0, ((158*eighth_scale/2)+(eighth_scale/4 + eighth_scale/2)+offset)}, //special note - not on eight note time
				{2, 160},
				{1, 161},
				{0, 162},
				{3, 164},
				{1, 165},
				{2, 167},
				{0, 169},
				{3, 170},
				{2, 178},
				{0, 180},
				{1, 181},
				{2, 183},
				{1, 185},
				{3, 186},
				{0, 194},
				{1, 194},
				{2, 196},
				{3, 196},
				{0, 198},
				{1, 200},
				{3, 200},
				{2, 202},
				{0, 204},
				{1, 204},
				{2, 206},
				{1, 208},
				{3, 208},
				{0, 210},
				{2, 212},
				{1, 212},
				{3, 214},
				{0, 216},
				{2, 216},
				{1, 218},
				{0, 220},
				{3, 220},
				{2, 222},
				{1, 224},
				{3, 224},
				{0, 226},
				{1, 227},
				{2, 228},
				{0, 229},
				{1, 230},
				{2, 231},
				{3, 232},
				{1, 233},
				{0, 234},
				{2, 235},
				{3, 236},
				{1, 237},
				{0, 238},
				{3, 239},
				{2, 240},
				{1, 241},
				{0, 242},
				{2, 244},
				{3, 244},
				{0, 245},
				{1, 245},
				{0, 247},
				{3, 247},
				{1, 249},
				{2, 249},
				{0, 250},
				{3, 250},
				{0, 258},
				{1, 258},
				{2, 261},
				{1, 264},
				{0, 267},
				{2, 274},
				{3, 274},
				{1, 277},
				{0, 280},
				{2, 283},
				{1, 286},
				{3, 286},
				{0, 287},
				{2, 287},
				{2, 290},
				{3, 290},
				{0, 293},
				{1, 296},
				{2, 299},
				{0, 302},
				{3, 302},
				{0, 306},
				{1, 306},
				{3, 309},
				{2, 312},
				{1, 315},
				{0, 318},
				{1, 318},
				{2, 319},
				{3, 319},
				{0, 322},
				{1, 322},
				{0, 324},
				{1, 325},
				{2, 325},
				{3, 327},
				{0, 328},
				{1, 328},
				{3, 330},
				{1, 331},
				{2, 331},
				{0, 333},
				{2, 334},
				{3, 334},
				{0, 336},
				{1, 336},
				{2, 338},
				{3, 338},
				{0, 340},
				{1, 341},
				{2, 341},
				{3, 343},
				{0, 344},
				{1, 344},
				{3, 346},
				{1, 347},
				{2, 347},
				{3, 349},
				{0, 350},
				{1, 350},
				{2, 352},
				{3, 352},
				{0, 354},
				{1, 354},
				{3, 356},
				{1, 357},
				{2, 357},
				{0, 359},
				{2, 360},
				{3, 360},
				{0, 362},
				{1, 363},
				{2, 363},
				{3, 365},
				{0, 366},
				{1, 366},
				{2, 368},
				{0, 370},
				{1, 371},
				{3, 372},
				{2, 373},
				{0, 374},
				{1, 375},
				{2, 376},
				{3, 377},
				{3, 379},
				{1, 380},
				{3, 381},
				{2, 382},
				{1, 383},
				{0, 384},
				{3, 386},
				{2, 386},
				{1, 389},
				{2, 391},
				{0, 394},
				{3, 394},
				{1, 397},
				{0, 399},
				{2, 402},
				{3, 402},
				{2, 405},
				{3, 407},
				{0, 410},
				{1, 410},
				{2, 412},
				{1, 414},
				{0, 416},
				{2, 418},
				{3, 418},
				{1, 421},
				{2, 423},
				{1, 426},
				{3, 426},
				{2, 429},
				{1, 431},
				{0, 434},
				{3, 434},
				{2, 437},
				{3, 439},
				{1, 442},
				{2, 442},
				{0, 444},
				{1, 446},
				{2, 448},
				{0, 450},
				{3, 450}










		//        [3 ... 49] = {-1,0}
		};

BYTE GetDriverandReport() {
	BYTE i;
//	BYTE rcode;
	BYTE device = 0xFF;
//	BYTE tmpbyte;

	DEV_RECORD* tpl_ptr;
	// xil_printf("Reached USB_STATE_RUNNING (0x40)\n");
	for (i = 1; i < USB_NUMDEVICES; i++) {
		tpl_ptr = GetDevtable(i);
		if (tpl_ptr->epinfo != NULL) {
			// xil_printf("Device: %d", i);
			// xil_printf("%s \n", devclasses[tpl_ptr->devclass]);
			device = tpl_ptr->devclass;
		}
	}
//	//Query rate and protocol
//	rcode = XferGetIdle(addr, 0, hid_device.interface, 0, &tmpbyte);
//	if (rcode) {   //error handling
//		// xil_printf("GetIdle Error. Error code: ");
//		// xil_printf("%x \n", rcode);
//	} else {
//		// xil_printf("Update rate: ");
//		// xil_printf("%x \n", tmpbyte);
//	}
//	// xil_printf("Protocol: ");
//	rcode = XferGetProto(addr, 0, hid_device.interface, &tmpbyte);
//	if (rcode) {   //error handling
//		// xil_printf("GetProto Error. Error code ");
//		// xil_printf("%x \n", rcode);
//	} else {
//		// xil_printf("%d \n", tmpbyte);
//	}
	return device;
}

void printHex (u32 data, unsigned channel)
{
	XGpio_DiscreteWrite (&Gpio_hex, channel, data);
}

uint32_t to_hex(int score) {
	int count = 0;
	int curr = score;
	int digit;
	uint32_t out = 0;

	while(curr != 0) {
		digit = curr%10;
		curr = curr/10;
		out = out + (digit<<(count*4));
		count++;
	}
	return out + 0x11111111;
}

void timer() {
	Status = XTmrCtr_Initialize(&Usb_timer2, XPAR_TIMER_USB_AXI_DEVICE_ID);
	XTmrCtr_Start(&Usb_timer2, 0);
}

void resetTimer() {
    XTmrCtr_Stop(&Usb_timer2, 0);
    XTmrCtr_Reset(&Usb_timer2, 0);
    XTmrCtr_Start(&Usb_timer2, 0);
}


int main() {
    init_platform();

    timer();
    int highscore = 0;


    XGpio_Initialize(&Gpio_hex, XPAR_GPIO_USB_KEYCODE_DEVICE_ID);
   	XGpio_SetDataDirection(&Gpio_hex, 1, 0x00000000); //configure hex display GPIO
   	XGpio_SetDataDirection(&Gpio_hex, 2, 0x00000000); //configure hex display GPIO
//   	BYTE rcode;
//	BOOT_MOUSE_REPORT buf;		//USB mouse report
	BOOT_KBD_REPORT kbdbuf;

	BYTE runningdebugflag = 0;//flag to dump out a bunch of information when we first get to USB_STATE_RUNNING
//	BYTE errorflag = 0; //flag once we get an error device so we don't keep dumping out state info
	BYTE device;

	// xil_printf("initializing MAX3421E...\n");
	MAX3421E_init();
	// xil_printf("initializing USB...\n");
	USB_init();

	while(1) {

		MAX3421E_Task();
		USB_Task();

		if (GetUsbTaskState() == USB_STATE_RUNNING) {
			if (!runningdebugflag) {
				runningdebugflag = 1;
				device = GetDriverandReport();
			} else if (device == 1) {
//				xil_printf("timer = %x\n", XTmrCtr_GetValue(&Usb_timer2, 0));
				kbdPoll(&kbdbuf);
				if(kbdbuf.keycode[0] == 0x28) {
					printHex (kbdbuf.keycode[0] + (kbdbuf.keycode[1]<<8) + (kbdbuf.keycode[2]<<16) + (kbdbuf.keycode[3]<<24), 1);
					usleep(5000);
					printHex(0,1);
					break;
				}
//				xil_printf("Keycodes: %x %x %x %x\n", kbdbuf.keycode[0], kbdbuf.keycode[1], kbdbuf.keycode[2], kbdbuf.keycode[3]);


				//Outputs the first 4 keycodes using the USB GPIO channel 1
//				printHex (kbdbuf.keycode[0] + (kbdbuf.keycode[1]<<8) + (kbdbuf.keycode[2]<<16) + (kbdbuf.keycode[3]<<24), 1);
				//Modify to output the last 2 keycodes on channel 2.
			}
		}

		else //not in USB running state
		{
			// xil_printf("USB task state: ");
			// xil_printf("%x\n", GetUsbTaskState());
			if (runningdebugflag) {	//previously running, reset USB hardware just to clear out any funky state, HS/FS etc
				runningdebugflag = 0;
				MAX3421E_init();
				USB_init();
			}
//			errorflag = 0;
		}
	}

	while(1){ //outer while start
//		textHDMIColorClr();


		int counter = 0;
		uint8_t score = 0;
		int totScore = 0;
		resetTimer();
		uint8_t should_poll = 0;
		uint8_t prev_lane_pressed[4] = {0};
		uint8_t clicked[4] = {0};
		uint8_t prevKeycode[4] = {0};



		for(int i=0; i<size; i++) {
			if(i == 78) {
				continue;
			}
			chart[i].y = chart[i].y*eighth_scale/2 + offset;

		}

		for(int x = 0; x < 200; x++){
			for(int y = 0; y < 480; y++){
				if((y > 447 && y < 451) || (x >= 0 && x < 2) || (x >= 198 && x < 200)){
					drawPixel(x, y, 1);
				} else {
					drawPixel (x,y,0);
				}
			}
		}


		while (1) {
			MAX3421E_Task();
			USB_Task();

			if (GetUsbTaskState() == USB_STATE_RUNNING) {
				if (!runningdebugflag) {
					runningdebugflag = 1;
					device = GetDriverandReport();
				} else if (device == 1) {
	//				xil_printf("timer = %x\n", XTmrCtr_GetValue(&Usb_timer2, 0));
					while(XTmrCtr_GetValue(&Usb_timer2, 0) < 0x100000) {};
					if (XTmrCtr_GetValue(&Usb_timer2, 0) >= 0x100000){

												kbdPoll(&kbdbuf);
							//
											xil_printf("Keycodes: %x %x %x %x\n", kbdbuf.keycode[0], kbdbuf.keycode[1], kbdbuf.keycode[2], kbdbuf.keycode[3]);
											if(kbdbuf.keycode[0] == 0x28 || kbdbuf.keycode[1] == 0x28 || kbdbuf.keycode[2] == 0x28 || kbdbuf.keycode[3] == 0x28 || kbdbuf.keycode[4] == 0x28 || kbdbuf.keycode[5] == 0x28) {
												for(int i=0; i<size; i++) {
													int drawY = chart[i].y + counter;
													int ybot = drawY + 30;
													if(chart[i].lane != -1 && ybot > -10 && ybot < 529) {
														removeNote(chart[i].lane, drawY);
													}
												}
												printHex (0x11111111, 2);
												printHex (0x28, 1);
												if(highscore < totScore){
													highscore = totScore;
												}
												xil_printf("High Score: %d\n", highscore);

												printHex(0,1);
												break;
											}
						clickedFunc(kbdbuf.keycode, prev_lane_pressed, clicked);
	//					xil_printf("timer = %x\n", XTmrCtr_GetValue(&Usb_timer2, 0));
						counter += 5;
	//					xil_printf("counter = %d\n", counter);
						resetTimer();
						for(int i=0; i<size; i++) {
							int drawY = chart[i].y + counter;
							int ybot = drawY + 30;
							if(chart[i].lane != -1 && ybot > -10 && ybot < 529) {
								drawNote(chart[i].lane, drawY);
								if(clicked[chart[i].lane] == 1) {
									if(ybot > 390){
										score = scoreCalc(ybot, 449, chart[i].lane);
										totScore += score;
//										xil_printf("Score: %d\n", totScore);
										printHex(to_hex(totScore)<<8, 2);
										removeNote(chart[i].lane, drawY);
										clicked[chart[i].lane] = 0;
										chart[i].lane = -1;
									}
								}
							}
						}
	//					xil_printf("%x\n",score);
						lightKeys(kbdbuf.keycode, score);
						for(int i=0; i<4; i++) {
							if(prevKeycode[i] != 0 && kbdbuf.keycode[i] == 0){
								score = 0;
							}
							prevKeycode[i] = kbdbuf.keycode[i];
						}
					}

					//Outputs the first 4 keycodes using the USB GPIO channel 1
	//				printHex (kbdbuf.keycode[0] + (kbdbuf.keycode[1]<<8) + (kbdbuf.keycode[2]<<16) + (kbdbuf.keycode[3]<<24), 1);
					//Modify to output the last 2 keycodes on channel 2.
				}
			}
	//		else if (GetUsbTaskState() == USB_STATE_ERROR) {
	//			if (!errorflag) {
	//				errorflag = 1;
	//				// xil_printf("USB Error State\n");
	//				//print out string descriptor here
	//			}
	//		}
			else //not in USB running state
			{
				// xil_printf("USB task state: ");
				// xil_printf("%x\n", GetUsbTaskState());
				if (runningdebugflag) {	//previously running, reset USB hardware just to clear out any funky state, HS/FS etc
					runningdebugflag = 0;
					MAX3421E_init();
					USB_init();
				}
	//			errorflag = 0;
			}
		}
	} //outer while end
    cleanup_platform();
	return 0;
}
