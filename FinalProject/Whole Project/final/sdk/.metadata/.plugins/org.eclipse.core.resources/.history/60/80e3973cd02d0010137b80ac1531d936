#include <stdio.h>
#include "platform.h"
#include "lw_usb/GenericMacros.h"
#include "lw_usb/GenericTypeDefs.h"
#include "lw_usb/MAX3421E.h"
#include "lw_usb/USB.h"
#include "lw_usb/usb_ch9.h"
#include "lw_usb/transfer.h"
#include "lw_usb/HID.h"

#include "xparameters.h"
#include <xgpio.h>

#include <xtmrctr.h>
#include "xintc.h"

extern HID_DEVICE hid_device;

static XGpio Gpio_hex;
static XGpio Gpio_high_score;

XTmrCtr Usb_timer2;
static int Status;

//static BYTE addr = 1; 				//hard-wired USB address
const char* const devclasses[] = { " Uninitialized", " HID Keyboard", " HID Mouse", " Mass storage" };

typedef struct{
    int lane;
    int y;

}Note;

#define eighth_scale -525
#define offset -1275
#define size 556
Note chart[size];
Note const_chart[size] = {
		        {0, 0},
		        {3, 1},
		        {2, 2},
		        {1, 5},
		        {3, 8},
		        {1, 16},
				{0, 17},
				{2, 18},
				{1, 21},
				{3, 24},
				{3, 32},
				{0, 33},
				{2, 34},
				{0, 37},
				{1, 40},
				{0, 48},
				{2, 49},
				{3, 50},
				{2, 53},
				{0, 56},
				{3, 59},
				{2, 64},
				{0, 66},
				{3, 66},
				{1, 69},
				{2, 69},
				{1, 74},
				{3, 74},
				{0, 77},
				{2, 77},
		        {0, 82},
				{1, 82},
				{2, 85},
				{3, 85},
				{1, 90},
				{3, 91},
				{2, 93},
				{0, 94},
				{2, 98},
				{3, 98},
				{1, 101},
				{3, 101},
				{0, 106},
				{2, 106},
				{1, 109},
				{2, 109},
				{0, 114},
				{1, 114},
				{2, 118},
				{0, 120},
				{3, 120},
				{1, 121},
				{2, 121},
				{0, 126},
				{2, 126},
				{2, 130},
				{3, 130},
				{0, 132},
				{1, 132},
				{2, 134},
				{0, 136},
				{3, 136},
				{1, 138},
				{0, 140},
				{2, 140},
				{3, 142},
				{2, 144},
				{1, 144},
				{0, 146},
				{2, 148},
				{3, 148},
				{1, 150},
				{0, 152},
				{2, 152},
				{3, 154},
				{0, 156},
				{1, 156},
				{3, 158},
				{0, ((158*eighth_scale/8)+(eighth_scale/16 + eighth_scale/8)+offset)}, //special note - not on eight note time
				{2, 160},
				{1, 161},
				{0, 162},
				{3, 164},
				{1, 165},
				{2, 167},
				{0, 169},
				{3, 170},
				{2, 178},
				{0, 180},
				{1, 181},
				{2, 183},
				{1, 185},
				{3, 186},
				{0, 194},
				{1, 194},
				{2, 196},
				{3, 196},
				{0, 198},
				{1, 200},
				{3, 200},
				{2, 202},
				{0, 204},
				{1, 204},
				{2, 206},
				{1, 208},
				{3, 208},
				{0, 210},
				{2, 212},
				{1, 212},
				{3, 214},
				{0, 216},
				{2, 216},
				{1, 218},
				{0, 220},
				{3, 220},
				{2, 222},
				{1, 224},
				{3, 224},
				{0, 226},
				{1, 227},
				{2, 228},
				{0, 229},
				{1, 230},
				{2, 231},
				{3, 232},
				{1, 233},
				{0, 234},
				{2, 235},
				{3, 236},
				{1, 237},
				{0, 238},
				{3, 239},
				{2, 240},
				{1, 241},
				{0, 242},
				{2, 244},
				{3, 244},
				{0, 245},
				{1, 245},
				{0, 247},
				{3, 247},
				{1, 249},
				{2, 249},
				{0, 250},
				{3, 250},
				{0, 258},
				{1, 258},
				{2, 261},
				{1, 264},
				{0, 267},
				{2, 274},
				{3, 274},
				{1, 277},
				{0, 280},
				{2, 283},
				{1, 286},
				{3, 286},
				{0, 287},
				{2, 287},
				{2, 290},
				{3, 290},
				{0, 293},
				{1, 296},
				{2, 299},
				{0, 302},
				{3, 302},
				{0, 306},
				{1, 306},
				{3, 309},
				{2, 312},
				{1, 315},
				{0, 318},
				{1, 318},
				{2, 319},
				{3, 319},
				{0, 322},
				{1, 322},
				{0, 324},
				{1, 325},
				{2, 325},
				{3, 327},
				{0, 328},
				{1, 328},
				{3, 330},
				{1, 331},
				{2, 331},
				{0, 333},
				{2, 334},
				{3, 334},
				{0, 336},
				{1, 336},
				{2, 338},
				{3, 338},
				{0, 340},
				{1, 341},
				{2, 341},
				{3, 343},
				{0, 344},
				{1, 344},
				{3, 346},
				{1, 347},
				{2, 347},
				{3, 349},
				{0, 350},
				{1, 350},
				{2, 352},
				{3, 352},
				{0, 354},
				{1, 354},
				{3, 356},
				{1, 357},
				{2, 357},
				{0, 359},
				{2, 360},
				{3, 360},
				{0, 362},
				{1, 363},
				{2, 363},
				{3, 365},
				{0, 366},
				{1, 366},
				{2, 368},
				{0, 370},
				{1, 371},
				{3, 372},
				{2, 373},
				{0, 374},
				{1, 375},
				{2, 376},
				{3, 377},
				{3, 379},
				{1, 380},
				{3, 381},
				{2, 382},
				{1, 383},
				{0, 384},
				{3, 386},
				{2, 386},
				{1, 389},
				{2, 391},
				{0, 394},
				{3, 394},
				{1, 397},
				{0, 399},
				{2, 402},
				{3, 402},
				{2, 405},
				{3, 407},
				{0, 410},
				{1, 410},
				{2, 412},
				{1, 414},
				{0, 416},
				{2, 418},
				{3, 418},
				{1, 421},
				{2, 423},
				{1, 426},
				{3, 426},
				{2, 429},
				{1, 431},
				{0, 434},
				{3, 434},
				{2, 437},
				{3, 439},
				{1, 442},
				{2, 442},
				{0, 444},
				{1, 446},
				{2, 448},
				{0, 450},
				{3, 450},
				{2, 454},
				{1, 458},
				{3, 462},
				{0, 466},
				{1, 466},
				{3, 470},
				{2, 474},
				{1, 482},
				{3, 482},
				{2, 486},
				{0, 488},
				{3, 489},
				{1, 490},
				{2, 490},
				{0, 494},
				{2, 496},
				{0, 497},
				{2, 498},
				{3, 498},
				{0, 499},
				{3, 500},
				{1, 501},
				{3, 502},
				{0, 503},
				{2, 504},
				{0, 505},
				{3, 506},
				{0, 507},
				{1, 508},
				{2, 510},
				{0, 512},
				{1, 514},
				{3, 514},
				{0, 516},
				{2, 516},
				{3, 519},
				{1, 520},
				{0, 522},
				{3, 522},
				{1, 523},
				{2, 524},
				{2, 526},
				{3, 526},
				{0, 527},
				{1, 528},
				{0, 530},
				{3, 530},
				{2, 531},
				{1, 532},
				{2, 534},
				{3, 534},
				{0, 535},
				{1, 536},
				{0, 538},
				{2, 538},
				{3, 539},
				{2, 540},
				{0, 542},
				{1, 542},
				{3, 543},
				{2, 544},
				{0, 545},
				{3, 546},
				{1, 547},
				{3, 548},
				{1, 550},
				{2, 550},
				{0, 551},
				{2, 552},
				{1, 554},
				{3, 554},
				{0, 555},
				{2, 556},
				{0, 558},
				{3, 558},
				{2, 559},
				{1, 560},
				{0, 562},
				{2, 562},
				{3, 563},
				{1, 564},
				{0, 566},
				{3, 566},
				{1, 567},
				{2, 568},
				{0, 570},
				{1, 570},
				{3, 571},
				{1, 572},
				{2, 572},
				{0, ((570*eighth_scale/8)+(eighth_scale/16 + eighth_scale/8)+offset)},
				{3, ((570*eighth_scale/8)+(eighth_scale/16 + eighth_scale/8)+offset)},
				{1, 575},
				{0, 575},
				{2, 576},
				{3, 576},
				{0, 578},
				{2, 580},
				{3, 580},
				{0, 582},
				{1, 582},
				{3, 583},
				{2, 584},
				{0, 586},
				{3, 586},
				{2, 587},
				{1, 588},
				{2, 590},
				{3, 590},
				{0, 591},
				{1, 592},
				{0, 594},
				{3, 594},
				{1, 595},
				{2, 596},
				{1, 598},
				{3, 598},
				{0, 599},
				{2, 600},
				{0, 602},
				{1, 602},
				{3, 603},
				{2, 604},
				{0, 605},
				{1, 606},
				{3, 607},
				{1, 608},
				{2, 609},
				{0, 610},
				{2, 611},
				{3, 612}, // triplet
				{0, 620},
				{3, 624},
				{0, 628},
				{1, 629},
				{3, 630},
				{2, 631},
				{1, 632},
				{3, 633},
				{2, 634},
				{1, 635},
				{0, 636},
				{3, 636},
				{1, ((634*eighth_scale/8)+(eighth_scale/16 + eighth_scale/8)+offset)},
				{2, ((634*eighth_scale/8)+(eighth_scale/16 + eighth_scale/8)+offset)},
				{0, 639},
				{1, 639},
				{2, 640},
				{3, 640},
				{0, 642},
				{2, 644},
				{3, 644},
				{1, 646},
				{0, 647},
				{2, 647},
				{1, 649},
				{2, 650},
				{3, 650},
				{0, 652},
				{1, 653},
				{2, 653},
				{0, 655},
				{2, 656},
				{3, 656},
				{0, 658},
				{1, 658},
				{2, 660},//tab
				{3, 660},
				{0, 663},
				{2, 663},
				{1, 666},
				{3, 666},
				{0, 669},
				{2, 669},
				{0, 672},
				{1, 672},
				{3, 674},
				{2, 674},
				{0, 676},
				{1, 676},
				{3, 678},
				{1, 679},
				{2, 679},
				{0, 681},
				{2, 682},
				{3, 682},
				{1, 684},
				{2, 685},
				{3, 685},
				{0, 687},
				{1, 688},
				{2, 688},
				{0, 690},
				{3, 690},
				{1, 692},
				{2, 692},
				{1, 695},
				{3, 695},
				{0, 698},
				{2, 698},
				{1, 700},
				{2, 701},
				{3, 702},
				{2, 704},
				{1, 706},
				{2, 708},
				{3, 708},
				{0, 709},
				{1, 710},
				{2, 711},
				{0, 712},
				{1, 713},
				{3, 714},
				{2, 715},
				{0, 716},
				{1, 717},
				{3, 718},
				{2, 719},
				{1, 720},
				{0, 721},
				{2, 722},
				{1, 723},
				{3, 724},
				{2, 725},
				{0, 726},
				{1, 727},
				{2, 728},
				{3, 729},
				{1, 730},
				{2, 731},
				{3, 732}, //triplet pt2
				{2, 736},
				{1, 740},
				{0, 741},
				{2, 742},
				{0, 743},
				{3, 744},
				{1, 745},
				{3, 746},
				{0, 747},
				{2, 748},
				{0, 749},
				{3, 750},
				{1, 751},
				{2, 752},
				{0, 753},
				{1, 754},
				{2, 755},
				{3, 756},
				{2, 760},
				{3, 760},
				{0, 761},
				{1, 762},
				{2, 763},
				{1, 764},
				{3, 764},
				{0, 765},
				{3, 766},
				{2, 767},
				{0, 768},
				{1, 769},
				{2, 770},
				{3, 771},
				{0, 772},
				{1, 772},
				{1, 775},
				{2, 775},
				{2, 778},
				{3, 778},
				{0, 786},
				{1, 787},
				{2, 788},
				{1, 791},
				{3, 794},
				{1, 802},
				{0, 803},
				{2, 804},
				{1, 807},
				{3, 810},
				{3, 818},
				{0, 819},
				{2, 820},
				{0, 823},
				{1, 826}



		//        [3 ... 49] = {-1,0}
		};

BYTE GetDriverandReport() {
	BYTE i;
//	BYTE rcode;
	BYTE device = 0xFF;
//	BYTE tmpbyte;

	DEV_RECORD* tpl_ptr;
	// xil_printf("Reached USB_STATE_RUNNING (0x40)\n");
	for (i = 1; i < USB_NUMDEVICES; i++) {
		tpl_ptr = GetDevtable(i);
		if (tpl_ptr->epinfo != NULL) {
			// xil_printf("Device: %d", i);
			// xil_printf("%s \n", devclasses[tpl_ptr->devclass]);
			device = tpl_ptr->devclass;
		}
	}
//	//Query rate and protocol
//	rcode = XferGetIdle(addr, 0, hid_device.interface, 0, &tmpbyte);
//	if (rcode) {   //error handling
//		// xil_printf("GetIdle Error. Error code: ");
//		// xil_printf("%x \n", rcode);
//	} else {
//		// xil_printf("Update rate: ");
//		// xil_printf("%x \n", tmpbyte);
//	}
//	// xil_printf("Protocol: ");
//	rcode = XferGetProto(addr, 0, hid_device.interface, &tmpbyte);
//	if (rcode) {   //error handling
//		// xil_printf("GetProto Error. Error code ");
//		// xil_printf("%x \n", rcode);
//	} else {
//		// xil_printf("%d \n", tmpbyte);
//	}
	return device;
}

void printHex (u32 data, unsigned channel)
{
	XGpio_DiscreteWrite (&Gpio_hex, channel, data);
}

uint32_t to_hex(int score) {
	int count = 0;
	int curr = score;
	int digit;
	uint32_t out = 0;

	while(curr != 0) {
		digit = curr%10;
		curr = curr/10;
		out = out + (digit<<(count*4));
		count++;
	}
	return out + 0x11111111;
}

void timer() {
	Status = XTmrCtr_Initialize(&Usb_timer2, XPAR_TIMER_USB_AXI_DEVICE_ID);
	XTmrCtr_Start(&Usb_timer2, 0);
}

void resetTimer() {
    XTmrCtr_Stop(&Usb_timer2, 0);
    XTmrCtr_Reset(&Usb_timer2, 0);
    XTmrCtr_Start(&Usb_timer2, 0);
}


int main() {
    init_platform();

    timer();
    int highscore = 0;


    XGpio_Initialize(&Gpio_hex, XPAR_GPIO_USB_KEYCODE_DEVICE_ID);
   	XGpio_SetDataDirection(&Gpio_hex, 1, 0x00000000); //configure hex display GPIO
   	XGpio_SetDataDirection(&Gpio_hex, 2, 0x00000000); //configure hex display GPIO
   	XGpio_Initialize(&Gpio_high_score, XPAR_AXI_GPIO_0_DEVICE_ID);
   	XGpio_SetDataDirection(&Gpio_high_score, 1, 0x00000000); //configure hex display GPIO

//   	BYTE rcode;
//	BOOT_MOUSE_REPORT buf;		//USB mouse report
	BOOT_KBD_REPORT kbdbuf;

	BYTE runningdebugflag = 0;//flag to dump out a bunch of information when we first get to USB_STATE_RUNNING
//	BYTE errorflag = 0; //flag once we get an error device so we don't keep dumping out state info
	BYTE device;

	// xil_printf("initializing MAX3421E...\n");
	MAX3421E_init();
	// xil_printf("initializing USB...\n");
	USB_init();

	sleep(10;)

	while(1) {

		MAX3421E_Task();
		USB_Task();

		if (GetUsbTaskState() == USB_STATE_RUNNING) {
			if (!runningdebugflag) {
				runningdebugflag = 1;
				device = GetDriverandReport();
			} else if (device == 1) {
//				xil_printf("timer = %x\n", XTmrCtr_GetValue(&Usb_timer2, 0));
				kbdPoll(&kbdbuf);
				if(kbdbuf.keycode[0] == 0x28) {
					printHex (kbdbuf.keycode[0] + (kbdbuf.keycode[1]<<8) + (kbdbuf.keycode[2]<<16) + (kbdbuf.keycode[3]<<24), 1);
					usleep(5000);
					printHex(0,1);
					break;
				}
//				xil_printf("Keycodes: %x %x %x %x\n", kbdbuf.keycode[0], kbdbuf.keycode[1], kbdbuf.keycode[2], kbdbuf.keycode[3]);


				//Outputs the first 4 keycodes using the USB GPIO channel 1
//				printHex (kbdbuf.keycode[0] + (kbdbuf.keycode[1]<<8) + (kbdbuf.keycode[2]<<16) + (kbdbuf.keycode[3]<<24), 1);
				//Modify to output the last 2 keycodes on channel 2.
			}
		}

		else //not in USB running state
		{
			// xil_printf("USB task state: ");
			// xil_printf("%x\n", GetUsbTaskState());
			if (runningdebugflag) {	//previously running, reset USB hardware just to clear out any funky state, HS/FS etc
				runningdebugflag = 0;
				MAX3421E_init();
				USB_init();
			}
//			errorflag = 0;
		}
	}
	int add_offset = 0;
	int maxAcc = 0;
	int accuracy = 0;
	while(1){ //outer while start
//		textHDMIColorClr();


		int counter = 0;
		uint8_t score = 0;
		int totScore = 0;
		resetTimer();
		uint8_t should_poll = 0;
		uint8_t prev_lane_pressed[4] = {0};
		uint8_t clicked[4] = {0};
		uint8_t prevKeycode[4] = {0};
		int pressed_plus;
		int pressed_minus;
		int pressed_zero;

		memcpy(chart, const_chart, sizeof(chart));


		for(int i=0; i<size; i++) {
			if(i == 78 || i==362 || i==363 || i==415 || i==416) {
				continue;
			}
			if(i>306) {

					chart[i].y = (chart[i].y-2)*eighth_scale/8 + offset;


			} else {
				chart[i].y = chart[i].y*eighth_scale/8 + offset;
			}


		}

		for(int x = 0; x < 200; x++){
			for(int y = 0; y < 480; y++){
				if((y > 447 && y < 451) || (x >= 0 && x < 2) || (x >= 198 && x < 200)){
					drawPixel(x, y, 1);
				} else {
					drawPixel (x,y,0);
				}
			}
		}


		while (1) {
			MAX3421E_Task();
			USB_Task();

			if (GetUsbTaskState() == USB_STATE_RUNNING) {
				if (!runningdebugflag) {
					runningdebugflag = 1;
					device = GetDriverandReport();
				} else if (device == 1) {
	//				xil_printf("timer = %x\n", XTmrCtr_GetValue(&Usb_timer2, 0));
					while(XTmrCtr_GetValue(&Usb_timer2, 0) < 0x100000) {};
					if (XTmrCtr_GetValue(&Usb_timer2, 0) >= 0x100000){

												kbdPoll(&kbdbuf);
							//
//											xil_printf("Keycodes: %x %x %x %x\n", kbdbuf.keycode[0], kbdbuf.keycode[1], kbdbuf.keycode[2], kbdbuf.keycode[3]);
											if(kbdbuf.keycode[0] == 0x28 || kbdbuf.keycode[1] == 0x28 || kbdbuf.keycode[2] == 0x28 || kbdbuf.keycode[3] == 0x28 || kbdbuf.keycode[4] == 0x28 || kbdbuf.keycode[5] == 0x28) {
												for(int i=0; i<size; i++) {
													int drawY = chart[i].y + counter + add_offset;
													int ybot = drawY + 30;
													if(chart[i].lane != -1 && ybot > -10 && ybot < 529) {
														removeNote(chart[i].lane, drawY);
													}
												}
												printHex (0x11111111, 2);
												printHex (0x28, 1);
												if(highscore < totScore){
													highscore = totScore;
												}
												xil_printf("High Score: %d\n", highscore);

												printHex(0,1);
												break;
											}
											if(kbdbuf.keycode[0] == 0x2E && !pressed_plus) {
												add_offset -= 3;
												pressed_plus = 1;
											} else {
												pressed_plus = 0;
											}
											if(kbdbuf.keycode[0] == 0x2D && !pressed_minus) {
												add_offset += 3;
												pressed_minus = 1;
											} else {
												pressed_minus = 0;
											}
											if(kbdbuf.keycode[0] == 0x27 && !pressed_zero) {
												add_offset = 0;
												pressed_zero = 1;
											} else {
												pressed_zero = 0;
											}
						clickedFunc(kbdbuf.keycode, prev_lane_pressed, clicked);
	//					xil_printf("timer = %x\n", XTmrCtr_GetValue(&Usb_timer2, 0));
						counter += 5;
	//					xil_printf("counter = %d\n", counter);
						resetTimer();
						for(int i=0; i<size; i++) {
							int drawY = chart[i].y + counter + add_offset;
							int ybot = drawY + 30;
							if(chart[i].lane != -1 && ybot >= 529){
								maxAcc += 100;
								chart[i].lane = -1;
							}
							else if(chart[i].lane != -1 && ybot > -10 && ybot < 529) {
								drawNote(chart[i].lane, drawY);
								if(clicked[chart[i].lane] == 1) {
									if(ybot > 390){
										score = scoreCalc(ybot, 449, chart[i].lane);
										totScore += score;
//										xil_printf("Score: %d\n", totScore);
										if(highscore < totScore){
											highscore = totScore;
										}
										printHex(to_hex(totScore)<<8, 2);
										XGpio_DiscreteWrite (&Gpio_high_score, 1, to_hex(totScore)<<8);
										removeNote(chart[i].lane, drawY, maxAcc);
										maxAcc += 100;
										clicked[chart[i].lane] = 0;
										chart[i].lane = -1;
									}
								}
							}
						}
//						xil_printf("Max Acc: %u \n",maxAcc);
//						xil_printf("Tot Score: %u \n",totScore);
						accuracy = (100*totScore)/maxAcc;
						xil_printf("Accuracy: %u\n",accuracy);
//						xil_printf("%u\n",score);
						lightKeys(kbdbuf.keycode, score);
						for(int i=0; i<4; i++) {
							if(prevKeycode[i] != 0 && kbdbuf.keycode[i] == 0){
								score = 0;
							}
							prevKeycode[i] = kbdbuf.keycode[i];
						}
					}

					//Outputs the first 4 keycodes using the USB GPIO channel 1
	//				printHex (kbdbuf.keycode[0] + (kbdbuf.keycode[1]<<8) + (kbdbuf.keycode[2]<<16) + (kbdbuf.keycode[3]<<24), 1);
					//Modify to output the last 2 keycodes on channel 2.
				}
			}
	//		else if (GetUsbTaskState() == USB_STATE_ERROR) {
	//			if (!errorflag) {
	//				errorflag = 1;
	//				// xil_printf("USB Error State\n");
	//				//print out string descriptor here
	//			}
	//		}
			else //not in USB running state
			{
				// xil_printf("USB task state: ");
				// xil_printf("%x\n", GetUsbTaskState());
				if (runningdebugflag) {	//previously running, reset USB hardware just to clear out any funky state, HS/FS etc
					runningdebugflag = 0;
					MAX3421E_init();
					USB_init();
				}
	//			errorflag = 0;
			}
		}
	} //outer while end
    cleanup_platform();
	return 0;
}
